# BiblioQuest: The "Infinite" Text Adventure

## 1. The Core Concept

**Problem**: Mobile games can be mindless; reading classics can feel like "work".
**Solution**: Turn public domain literature into an interactive RPG (MUD).
**Hook**: "Fight your way through The Odyssey."

## 2. Architecture & Technologies

### 2.1. APIs

- **Project Gutenberg / Open Library**: Source for raw text of public domain books.
  - _Challenge_: Robust parsing to remove headers/footers and extract clean chapters.
- **Open5e / D&D 5e API**: Source for RPG stats (Monsters, Spells, Items).
  - _Usage_: Fetch stat blocks for identified entities (e.g., getting the stats for a "Wolf" or "Vampire").
- **AI Integration (The "Dungeon Master")**:
  - **Role**: Narrative Parser & Dynamic Game Master.
  - **Responsibilities**:
    - **Live Reading**: Stream text and analyze context in real-time.
    - **Entity Extraction**: Identify enemies ("Grendel"), challenges ("Climb the cliff"), or social encounters.
    - **Stat Mapping**: Map literary descriptions to the closest D&D 5e equivalent.
    - **Narration**: Generate combat flavor text and resolve actions.

### 2.2. Frontend (Next.js)

- **UI Components**:
  - **Reader Interface**: Elegant typography, distraction-free reading mode.
  - **DM Overlay / Console**: Slides in when an event triggers. This is the "Game Layer".
  - **Character HUD**: Persistent footer/header showing HP, AC, and Inventory.
- **State Management**:
  - **Narrative State**: Current Book, Chapter, Paragraph Index.
  - **GameState**: Player Stats (HP, XP, Class), Inventory, Active Combat State.

## 3. The Gameplay Loop (The Workflow)

1.  **Selection**: User selects _The Odyssey_.
2.  **Character Setup**:
    - _Auto-Generate_: "Play as Odysseus" (Fighter/Rogue stats generated by AI).
    - _Custom_: "I want to play as a Wizard in _The Odyssey_."
3.  **Reading Phase (Exploration)**:
    - The user reads the text.
    - Background AI Process: Analyzes the upcoming text buffer for keywords/context.
4.  **The Trigger (Interruption)**:
    - _Text segment_: "...and the Cyclops Polyphemus blocked the cave mouth."
    - _AI Logic_: `DETECTED_HOSTILE: Cyclops. THREAT: Deadly. ACTION: Initiate Combat.`
    - _UI Effect_: Reading pauses. The screen shakes (maybe). The "Combat Encounter" UI takes focus.
5.  **Combat/Interaction Phase**:
    - Turn-based combat using 5e rules.
    - Player Options: attack, cast spell, use item, or _narrative actions_ (e.g., "Blind him" - specific to the book).
    - _Outcome_:
      - **Victory**: Gain XP, Loot. The obstruction is cleared. Resume reading.
      - **Defeat**: "You have perished." Reload chapter or penalty applied.

## 4. Implementation Roadmap

### Phase 1: The Reader & The Library

- Set up Next.js project structure.
- Implement `useBookFetcher` hook to get text from Project Gutenberg.
- Build a clean, scrollable Reader component.

### Phase 2: The DM Brain (AI)

- Design the Prompt Engineering for the "Observer" AI.
  - _Prompt_: "Read the following text. Identify if a hostile encounter, skill check, or item acquisition occurs. JSON Output."
- Implement the API route for the AI analysis.

### Phase 3: The Game Engine (RPG Layer)

- Integrate D&D 5e API.
- Build the Combat System (Initiative, Attacks, HP tracking).
- Create the UI for the combat overlay.

### Phase 4: Integration

- Wire the "Observer" output to trigger the Game Engine.
- Handle state transitions (Reading -> Fighting -> Reading).

## 5. Future Ideas

- **Inventory System**: Loot items from the book (e.g., _The One Ring_ in a different book?).
- **Classics Multiverse**: Take your character from _Dracula_ into _Moby Dick_.
